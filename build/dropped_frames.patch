diff --git a/src/main_headless.cpp b/src/main_headless.cpp
index 0577339ba84e848dbc043d45158f5fe98b588f74..2818d5bfba9d4b0b9971351ab4aed045139dcc0f 100644
--- a/src/main_headless.cpp
+++ b/src/main_headless.cpp
@@ -109,79 +109,82 @@ void capture_thread(FrameCapture* capture, LockFreeQueue<FrameData>* queue,
     uint64_t frame_count = 0;
     
     while (running) {
         auto start = high_resolution_clock::now();
         
         if (capture->grab(frame)) {
             FrameData data;
             data.frame = frame.clone();
             data.timestamp = duration_cast<microseconds>(
                 high_resolution_clock::now().time_since_epoch()).count();
             data.frame_id = frame_count++;
             
             if (!queue->push(data)) {
                 stats->dropped_frames++;
             }
             
             auto end = high_resolution_clock::now();
             stats->capture_time = duration_cast<microseconds>(end - start).count();
         }
     }
 }
 
 void process_thread(LockFreeQueue<FrameData>* input_queue,
                    Detector* detector, KalmanTracker* tracker,
                    std::atomic<bool>& running, PerfStats* stats,
+                   std::atomic<int>& frames_processed,
                    std::ofstream* output_file = nullptr) {
     
     FrameData frame_data;
     
     while (running) {
         if (input_queue->pop(frame_data)) {
             auto start = high_resolution_clock::now();
             
             cv::Point2f puck_pos;
             bool detected = detector->detect(frame_data.frame, puck_pos);
             
             if (detected) {
                 tracker->update(puck_pos, frame_data.timestamp);
             } else {
                 tracker->predictOnly(frame_data.timestamp);
             }
             
             // Zapisz dane do pliku CSV
             if (output_file && output_file->is_open()) {
                 auto pos = tracker->getPosition();
                 auto vel = tracker->getVelocity();
                 *output_file << frame_data.timestamp << ","
                            << pos.x << "," << pos.y << ","
                            << vel.x << "," << vel.y << ","
                            << detected << std::endl;
             }
             
             auto end = high_resolution_clock::now();
             stats->process_time = duration_cast<microseconds>(end - start).count();
+
+            frames_processed++;
             
             // Wyświetl status w konsoli
             if (frame_data.frame_id % 30 == 0) {  // Co 30 klatek
                 auto pos = tracker->getPosition();
                 auto vel = tracker->getVelocity();
                 std::cout << "\rFrame: " << frame_data.frame_id 
                          << " | Pos: (" << std::fixed << std::setprecision(1) 
                          << pos.x << ", " << pos.y << ")"
                          << " | Vel: (" << vel.x << ", " << vel.y << ")"
                          << " | " << (detected ? "TRACKED" : "LOST   ")
                          << std::flush;
             }
         } else {
             std::this_thread::sleep_for(microseconds(100));
         }
     }
 }
 
 int main(int argc, char* argv[]) {
     Config cfg = parse_args(argc, argv);
     
     std::signal(SIGINT, signal_handler);
     std::signal(SIGTERM, signal_handler);
     
     // Load YAML config
diff --git a/src/main_headless.cpp b/src/main_headless.cpp
index 0577339ba84e848dbc043d45158f5fe98b588f74..2818d5bfba9d4b0b9971351ab4aed045139dcc0f 100644
--- a/src/main_headless.cpp
+++ b/src/main_headless.cpp
@@ -199,67 +202,68 @@ int main(int argc, char* argv[]) {
         output_file << "timestamp,x,y,vx,vy,detected" << std::endl;
     }
     
     // Initialize components
     auto capture = std::make_unique<FrameCapture>(cfg.backend, cfg.width, 
                                                   cfg.height, cfg.fps);
     
     if (!capture->initialize()) {
         std::cerr << "Failed to initialize capture device!" << std::endl;
         return -1;
     }
     
     auto detector = std::make_unique<Detector>(yaml_config);
     auto tracker = std::make_unique<KalmanTracker>(yaml_config);
     auto stats = std::make_shared<PerfStats>();
     
     // Create queue
     LockFreeQueue<FrameData> capture_queue(cfg.queue_size);
     
     std::cout << "Starting puck tracker (headless mode)..." << std::endl;
     std::cout << "Resolution: " << cfg.width << "x" << cfg.height 
               << " @ " << cfg.fps << " FPS" << std::endl;
     std::cout << "Press Ctrl+C to stop" << std::endl;
     
     // Start threads
-    std::thread capture_t(capture_thread, capture.get(), &capture_queue, 
+    std::thread capture_t(capture_thread, capture.get(), &capture_queue,
                          std::ref(g_running), stats.get());
-    
+
+    std::atomic<int> frames_processed{0};
     std::thread process_t(process_thread, &capture_queue,
                          detector.get(), tracker.get(), std::ref(g_running),
-                         stats.get(), cfg.save_output ? &output_file : nullptr);
-    
+                         stats.get(), std::ref(frames_processed),
+                         cfg.save_output ? &output_file : nullptr);
+
     // Performance monitoring loop
     auto last_stats_update = high_resolution_clock::now();
-    int frames_processed = 0;
     
     while (g_running) {
         std::this_thread::sleep_for(seconds(1));
         
         auto now = high_resolution_clock::now();
         auto elapsed = duration_cast<seconds>(now - last_stats_update).count();
         
         if (elapsed >= 1 && cfg.enable_profiling) {
-            float fps = frames_processed / static_cast<float>(elapsed);
-            
+            int processed = frames_processed.exchange(0);
+            float fps = processed / static_cast<float>(elapsed);
+
             std::cout << "\n[STATS] FPS: " << std::fixed << std::setprecision(1) << fps
                      << " | Latency: " << stats->getLatency() << "ms"
                      << " | Drops: " << stats->dropped_frames
                      << " | Cap: " << stats->capture_time << "μs"
                      << " | Proc: " << stats->process_time << "μs" << std::endl;
-            
-            frames_processed = 0;
+
             last_stats_update = now;
         }
     }
     
     // Cleanup
     capture_t.join();
     process_t.join();
     
     if (output_file.is_open()) {
         output_file.close();
     }
     
     std::cout << "\nShutdown complete." << std::endl;
     return 0;
-}
+}
